import requests
from bs4 import BeautifulSoup
import requests
from termcolor import colored
from time import sleep
from pyxploitdb import searchCVE
import string
import pandas as pd

class ShodanScraper:
    def __init__(self, proxies, verbose=False):
        self.verbose = verbose
        self.proxies = proxies

    def verbose_print(self, message, color="white"):
        if self.verbose:
            print(colored(f"{message}", color))
    
    def sort_csv_by_column_count(csv_filename):
        # Determine the maximum number of columns
        max_cols = 0
        with open(csv_filename, 'r') as f:
            for line in f:
                max_cols = max(max_cols, line.count(',') + 1)
        
        # Read the CSV into a DataFrame with enough columns
        col_names = [f'Col_{i}' for i in range(max_cols)]
        df = pd.read_csv(csv_filename, header=None, names=col_names)
        
        # Sort Rows by Column Count
        df['non_na_count'] = df.notna().sum(axis=1)
        df_sorted = df.sort_values(by='non_na_count', ascending=False).drop(columns=['non_na_count'])
        return df_sorted.to_csv(csv_filename,index=False, header=False)

    def veryfiy_page(self, response):
        if response == False:
            self.verbose_print("Error: Response is False", "red")
        elif response.status_code != 200:
            self.verbose_print("Error: Response code: {}".format(response.status_code), "red")
        elif "Daily search usage limit reached" in response.text:
            self.verbose_print("Daily search usage limit reached", "yellow")
            return "Somewhat working"
        elif "Please create a" in response.text:
            self.verbose_print("Please create an account to view more results.", "yellow")
        elif "Result limit reached." in response.text:
            self.verbose_print("Result limit reached.", "yellow")
        else:
            return True
        return False
    
    def index_to_string(self,index):
        chars = string.ascii_letters + string.digits  # A-Z, a-z, 0-9
        base = len(chars)  # Base is the number of characters we are cycling through

        # Calculate string length based on index
        length = 1
        while index >= base ** length:
            index -= base ** length
            length += 1

        # Generate the string for the given index
        result = ""
        for _ in range(length):
            index, char_index = divmod(index, base)
            result = chars[char_index] + result

        return result

    def search_shodan(self, display_process_index="+"):
        self.display_process_index = display_process_index
        self.function_running = True
        #check for .csv file existence
        filename =  "found_ips.csv"
        try:
            with open(filename, "r") as file:
                #if file exists, read it
                pass
        except FileNotFoundError:
            self.search_index = 0
            #create a .csv file with headers
            data = {
                "ip": [], 
                "query": [], 
                "current_index": []  }
            df = pd.DataFrame(data)
            df.to_csv(filename, index=False)
            df = pd.read_csv(filename)
            df["current_index"] = [self.search_index]
            df.to_csv(filename, index=False)

        df = pd.read_csv(filename)
        #loop through pages
        while self.function_running:
            try:
                df = pd.read_csv(filename)
                self.search_index = int(df["current_index"][0])
                current_index = int(self.search_index)
                self.verbose_print(f"Searching Shodan for index: {self.search_index}", "blue")
                # Generate the string for the given index
                query = self.index_to_string(self.search_index)

                print(f"[ {display_process_index} ] "+colored(f"Searching Shodan for: {query}", "blue"))
                response, proxy = self.proxies.url_request(f"https://www.shodan.io/search?query={query}")
                if self.veryfiy_page(response) != True:
                    self.verbose_print(f"Error with {proxy} switching proxy", "red")
                    continue
                if "No results found" in response.text:
                    self.verbose_print(f"No results found for query: {query}", "red")
                    if int(current_index) >= int(self.search_index):
                        df["current_index"][0] = self.search_index + 1
                        df.to_csv(filename, index=False)
                    continue
                
                # Print the page source if verbose
                soup = BeautifulSoup(response.text, 'html.parser')
                self.verbose_print(soup.prettify(), "yellow")

                found_ips = []
                for div in soup.find_all("div", class_="heading"):
                    a = div.find("a", class_="title text-dark")
                    if a:
                        ip = a['href'][6:]
                        found_ips.append(ip) 
                if len(found_ips) == 0:
                    self.verbose_print(f"No IP addresses found for query: {query}", "red")
                    if current_index >= self.search_index:
                        df = pd.read_csv(filename)
                        df["current_index"][0] = current_index
                        df.to_csv(filename, index=False)
                    continue

                else:
                    self.verbose_print(f"IP addresses found for query: {query}", "green")
                    self.verbose_print(found_ips, "green")
                    if not int(current_index) >= int(self.search_index):
                        continue
                    for ip in found_ips:
                        df = pd.read_csv(filename)
                        if ip in df["ip"].values:
                            self.verbose_print(f"IP address already exists in the file: {ip}", "yellow")
                            continue
                        new_row = {'ip': ip, 'query': query, 'current_index': int(current_index)}
                        new_row = pd.DataFrame(new_row, index=[0])
                        with open(filename, 'a', newline='') as f:
                            new_row.to_csv(f, header=False, index=False)
                        self.verbose_print(f"New IP address added to the file: {ip}", "green")
                    df = pd.read_csv(filename)
                    df.loc[0, "current_index"] = int(current_index + 1)
                    self.verbose_print(f"Changing index to: {current_index + 1}", "green")
                    df.to_csv(filename, index=False)
                    print(f"[ + ]"+colored(f"Found: {len(found_ips)} IP addresses for query: {query}", "green"))
                    sleep(5)
                    self.proxies.confirm_working_proxy(proxy)
                sleep(1)
                continue
            except KeyboardInterrupt:
                self.running = False
                return print(colored("Exiting", "red"))
            except Exception as e:
                self.verbose_print(f"Error: {e}", "red")
                continue


    def get_exploits_for_ip(self, ip):
        self.verbose_print(ip)
        url = str("https://internetdb.shodan.io/"+ip)
        self.verbose_print(url)
        self.verbose_print("Searching CVE's for: {}".format(ip))
        host_info = None
        while host_info == None:
            # Get response from Shodan API
            host_info = requests.get(url).json()
        cve_list = host_info["vulns"]
        # Print scraped CVE's
        self.verbose_print("CVE's found for IP address {}:".format(ip))
        if len(cve_list) > 0:
            self.verbose_print(colored(cve_list, "green"))
        else:
            self.verbose_print(f"No CVE's found for IP address: {ip} :(", "red")
        # Search for exploits in ExploitDB
        self.verbose_print("Searching ExploitDB for exploits...", "light_magenta")
        for cve in cve_list:
            result = searchCVE(cve)
            if result == []:
                self.verbose_print(f"No exploits found for {cve}", "red")
                continue
            self.verbose_print(f"{cve} exploit found in ExploitDB")
            self.verbose_print(result, "green")

                # for exploit in result:
                #     self.verbose_print(exploit.link)
                